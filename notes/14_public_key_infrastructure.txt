Public Key Infrastructure (PKI)
-------------------------------

=> a systematic approach to proving and trusting keys and identities

- anybody can generate identities, the question is who is going to vouch for us so that the
  identity is a trusted one, how do we validate such and identity -> PKI
- we need connect these keys to valid real-time identities

- how are keys used?
    - when someone wants to send you an encrypted message
        - they use your public key to encrypt data
        - the encrypted data can only be decrypted by your private key
    - when you want to prove you identity to someone
        - you authenticate using digital signature
=> all of these use cases rely on people trusting the public keys

- who do we trust?
    - simply just downloading a public key from the internet is not safe, someone can
      intercept that message and send you their own public key
    => this is where PKI comes into play
    - PKI can prove the identity of a public key owner
    - the public key is encapsulated in a certificate, kind of a wrapper around the key
    - this certificate includes much more information that just the public key
        - name, country, scenarios to use the key for
        - most importantly, it has to be vouched for by somebody else, it has to be confirmed
          by a higher level of authority (certification authority)
    - we ask the CA to sign our certificate -> the CA calculates a hash of our certificate
      and then encrypts it with the CA's private key
    - CA's public keys are well known -> anyone can validate the signature
    - CAs must be trusted -> you trust the certificate
    - there can be a hierarchy of CAs, your certificate may be signed by a CA, that CA's
      certificate is signed by another CA, but somewhere in this hierarchy there must be
      someone that you trust as a CA
    - but again, everybody can 'be' a CA, in larger companies you can have local certification
      authorities

- trust between CAs
    - they have a hierarchy of trust
    - just one single CA -> vulnerable, exposed -> SPOF (single point of failure)
    - if the private key of a CA gets compromised, then every certificate ever generated by
      that CA becomes invalid
    => hierarchy of CAs, each signing the certificates of CAs below them
        - root CA > intermediate CA > leaf CA
        - certificate path (tree) -> chain of trust
        - leaf CA's certificate can be traced back to a root CA
    - why so complicated?
        - at one point we can completely take the root CA offline, it is then not exposed, not
          vulnerable
        - once the intermediate CAs are instantiated, the root CA is brought offline
        - if one of the leaf CA gets compromised, it is not a big problem, just invalidate its
          certificates, but the hierarchy is still up and running
    - root CA is only used to create other intermediate or leaf CAs, it is not used to sign
      any user certificates -> can be taken offline -> safe and secure

- Registration Authorities
    - RA checks the identity of an entity requesting a certificate
    - registration = creating an account with a CA, so that your identity is validated
    - then you can ask for certificates
    - CSR: certificate signing request
        - this is a form that everyone must fill out who wants to request a certificate
        - an ASCII file including every necessary information
            - name, identity
            - domain names you want to cover
            - is it a web server certificate?
            - your public key
        - CA has to validate this information before emitting the certificate
    - since a CA constantly receives CSRs, it is always exposed, therefor the processing of
      these CSRs is sometimes outsourced to a different entity called a Registration Authority
    - RA is also part of the PKI, it only deals with receiving and validating CSRs, they do
      not emit certificates

- after this process, you end up with a digital certificate
    - a file container for a public key
    - digital signature from a trusted CA
    - additional metadata/attributes
    - based on the X.509 IETF standard
    - there is an additional set of standards created by the RSA called PKCS (Public Key
      Cryptography Standards)
    - standards define what fields are allowed in a certificate, at what position, what data
      types, use cases
    - attributes
        - serial number: for checking the validity, a unique number identifying the
                         certificate, also useful for revoking it
        - signature algorithm: this was used to sign it, you need to know the algorithm to
                               know how to deal with it
        - signature hash algorithm
        - issuer: name of the CA who signed it
        - valid from: start of validity
        - valid to: end of validity (then it is expired)
        - subject: entity that certificate represents (it might be your name, your email
                   address, might be a domain name, ...)
        - public key
        - more extensions

- subjects on certificates (why or what does the certificate validate?)
    - CN (Common Name): not there anymore, was designed to be a fully qualified domain of the
                        website that the certificate is supposed to belong to
        -> explicit syntax was never defined -> now it is deprecated
    - SAN (Subject Alternative Name): this replaced CN, a list of all the subject covered by
                                      the certificate (e.g. domain names)
        -> there are often wildcard characters in there, like *.google.com

- certificate types (where can a certificate be used?)
    - key usage : what can that certificates be used for (signing emails, encrypting files)
        - this is a filed in the certificate
    - extended key usage (EKU, enhanced key usage on windows)
        - more flexible way of defining usages for a certificate
        - server authentication
        - client authentication
        - code signing (e.g. downloading an app)
        - email protection

- there are critical and non-critical extensions
    - if an extension is marked as critical, then the software processing that certificate
      must recognize that extension, if it does not, it should reject the certificate

- Web Server Certificates
    - guarantees a website's identity
    - very important, we are sharing data with websites all the time
    - different levels of security
        - domain validation: simple check, it proves that you are the owner of the domain that
          you are trying to register a certificate for
            - might require you to fill in some DNS records that can be publicly checked
            - or you might be required to send an email from the same domain
        - extended validation
            - for higher-profile websites
            - checks the legal identity of the owner
            - trying to avoid issuing certificates for spoofed domains, like amazoon.com

- other certificate types
    - users (email, disk encryption)
    - servers and apps
    - code signing (files, apps)
    - self-signed certificates: no one stops you from signing your own certificate, nobody is
      going to trust it, but it is still a correct certificate
        -> lab environments, local networks
        -> browser will say that it is not trusted
    - machine certificate: company laptops present this in the company network, this is why
      they have access to much more data than an external machine would

- life of a certificate
    - key creation (private key -> public key derived from private key)
    - create the certificate (send CSR, receive certificate)
    - store the certificate: load it into a certificate store so that it can be accessed by
      any applications that need to use it to validate someones identity
    - revoke the certificate: maybe expired, maybe private key was compromised
        - can be renewed, you can use the same key if it was not leaked

- secure management of keys
    - if you back up the key, you increase the risk that someone finds it
    - if you don't have a backup -> single point of failure
    - some processes for storing securely
        - key recovery: e.g. store segmented in different number of storage devices
        - key escrow: giving it to a third party for storage, if you don't want to invest in
                      the secure storage system yourself
    - expiration
    - revocation
        - CRL (Certificate Revocation List): list of revoked certificates issued by the CA
        - OCSP (Online Certification Status Protocol): relies on a request-reply protocol to
          ask whether a certain certificate with a specific serial number is revoked, expired
          or valid
            -> puts a lost of stress on the CA server
            -> delegate the web server that we are trying to access to respond on behalf of
               the CA
            -> the web server obtains a timestamped response from the CA
            -> it uses this response to answer further requests, so that it does not have to
               always go to the CA's server
            -> the server receives a signed response from the CA and then shows it to everyone
               who asks -> "hey, this is the signed response from the CA stating that my
               certificate is still valid"
            => this is called OCSP Stapling
    - man-in-the-middle attack?
        - what if someone intercepts your certificate request and injects their own signed and
          trusted certificate?
        - you will think that what you received was the one that you were looking for and then
          you might send your authentication data, credit card number, and you are going to
          encrypt this information with the public key that came with that bogus certificate
            -> all that information can be decrypted by the attacker
        => Certificate pinning (HPKP - HTTP public key pinning)
            - embedding the information in the original certificate somewhere the application
              code
            - somewhere within the webpage code of e.g. gmail there is the contents of google
              certificate
            - if the browser finds a set of information in the application code then it will
              compare it with the actual certificate that it actually received
        - this happens more than we would think, and not for malicious purposes
            - companies have to inspect the traffic of the employees, so that certain websites
              can be blocked
            - but all traffic nowadays is encrypted, so the companies firewall has to perform
              SSL decryption on the traffic
            - this means that the firewall has to replace the certificate that the user is
              actually expecting with its own certificate
            - if that website that you are trying to reach uses HPKP, then it will not work
            -> HPKP implementation are gradually backing off

- how do you store a certificate?
    - it is just a file -> store it on the disk
    - extensions:
        - .der : binary format, rare
        - .pen : ASCII format, easily copy-pasteable, base-64 encoding
        - .crt, .cer : maybe ASCII, maybe binary, it is not defined
        - PKCS #12 format : stores both the private key and the public key in the same file
            -> .pfx, .p12
            -> there are some situations where you want to move both keys at the same time,
               e.g. server update or backup
        - P7B format : stores the entire certificate chain, the whole hierarchy

- OpenSSH is often used on linux
    >> openssl req -newkey rsa:2048 -nodes -x509 -days 365 -out certificate.pem
        -> certificate
        -> RSA, 2048 bits
        -> 1 year expiration date
        -> self-signed certificate
    >> openssl genrsa -aes256 -out key.pem 4096                   -> private key
    >> openssl rsa -pubout -in key.pem -out key_pub.pem           -> public key from private
        -> 4096 bits
        -> aes256 : private key is going to be encrypted using a password
    >> openssl req -config openssl.cnf -key cakey.pem -new -x509 -days -days 7300 -sha256
       -out cacert.pem
        -> make you own CA and generate a certificate
    >> openssl req -nodes -new -newkey rsa:2048 -out www.csr -keyout www.key
        -> generate a CSR on a server
    >> openssl ca -config openssl.cnf -extensions webserver -infiles www.csr -out www.pem
        -> sing the CSR on the CA